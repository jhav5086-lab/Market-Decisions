# -*- coding: utf-8 -*-
"""Marketing Mix Modeling (MMM) Complete Analysis - Fixed Version.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1your_drive_link_here
"""

# Install compatible packages
!pip install plotly==5.15.0
!pip install seaborn==0.12.2
!pip install ipywidgets==7.7.1
!pip install scipy==1.10.1

import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.linear_model import LinearRegression, Ridge, Lasso
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from sklearn.preprocessing import StandardScaler
import joblib
from datetime import datetime
import warnings
from IPython.display import display, HTML
import ipywidgets as widgets
from ipywidgets import interact, interactive, fixed, interact_manual
import io

warnings.filterwarnings('ignore')

# Set plotting style
plt.style.use('default')
sns.set_palette("husl")
plt.rcParams['figure.figsize'] = (12, 8)

print("🚀 Marketing Mix Modeling Application Initialized!")

class MarketingMixModel:
    def __init__(self):
        self.df = None
        self.model = None
        self.scaler = StandardScaler()
        self.feature_importance = None
        self.model_results = None
        
    def load_sample_data(self):
        """Create sample dataset based on the provided structure"""
        # Generate sample data for demonstration
        np.random.seed(42)
        dates = pd.date_range('2018-01-01', '2020-12-31', freq='D')
        
        data = {
            'date': dates,
            'report_date_3': dates,
            'day_type': np.random.choice(['Avg day', 'Promo day- low', 'Promo day- mid', 
                                        'Promo day- high', 'Sale', 'Early access', 'FSNM', 'Influencer'], 
                                       len(dates), p=[0.6, 0.15, 0.1, 0.05, 0.05, 0.03, 0.01, 0.01]),
            'descriptor': 'Sample campaign',
            'paid_search_gross_spend': np.random.normal(1500, 500, len(dates)),
            'paid_search_net_spend': np.random.normal(1350, 450, len(dates)),
            'paid_search_revenue': np.random.normal(10000, 3000, len(dates)),
            'paid_search_impressions': np.random.normal(85000, 25000, len(dates)),
            'paid_search_clicks': np.random.normal(7000, 2000, len(dates)),
            'paid_shopping_gross_spend': np.random.normal(2700, 800, len(dates)),
            'paid_shopping_net_spend': np.random.normal(2450, 700, len(dates)),
            'paid_shopping_revenue': np.random.normal(1500, 500, len(dates)),
            'paid_shopping_impressions': np.random.normal(500000, 150000, len(dates)),
            'paid_display_gross_spend': np.random.normal(3300, 1000, len(dates)),
            'paid_display_net_spend': np.random.normal(2800, 800, len(dates)),
            'paid_display_revenue': np.random.normal(120, 50, len(dates)),
            'paid_display_impressions': np.random.normal(1500000, 500000, len(dates)),
            'paid_social_gross_spend': np.random.normal(1800, 600, len(dates)),
            'paid_social_net_spend': np.random.normal(1500, 500, len(dates)),
            'paid_social_revenue': np.random.normal(1600, 500, len(dates)),
            'paid_social_impressions': np.random.normal(600000, 200000, len(dates)),
            'organic_direct_revenue': np.random.normal(11500, 3000, len(dates)),
            'organic_search_revenue': np.random.normal(8300, 2000, len(dates)),
            'organic_social_revenue': np.random.normal(600, 200, len(dates)),
            'organic_referral_revenue': np.random.normal(300, 100, len(dates)),
            'holiday': np.random.choice(['None', 'New Year Day', 'Christmas', 'Black Friday', 'Valentines Day'], 
                                      len(dates), p=[0.8, 0.05, 0.05, 0.05, 0.05]),
            'year': [d.year for d in dates],
        }
        
        self.df = pd.DataFrame(data)
        
        # Remove negative values
        numeric_cols = self.df.select_dtypes(include=[np.number]).columns
        self.df[numeric_cols] = self.df[numeric_cols].clip(lower=0)
        
        # Calculate total revenue
        revenue_columns = [col for col in self.df.columns if 'revenue' in col.lower()]
        self.df['total_revenue'] = self.df[revenue_columns].sum(axis=1)
        
        # Add seasonality and trends
        self.df['month'] = self.df['date'].dt.month
        self.df['quarter'] = self.df['date'].dt.quarter
        self.df['day_of_week'] = self.df['date'].dt.dayofweek
        self.df['week_of_year'] = self.df['date'].dt.isocalendar().week
        
        # Add promotional impact
        promo_impact = {
            'Avg day': 1.0,
            'Promo day- low': 1.3,
            'Promo day- mid': 1.7,
            'Promo day- high': 2.2,
            'Sale': 2.8,
            'Early access': 1.4,
            'FSNM': 1.6,
            'Influencer': 1.8
        }
        
        self.df['promo_multiplier'] = self.df['day_type'].map(promo_impact)
        self.df['total_revenue'] = self.df['total_revenue'] * self.df['promo_multiplier']
        
        # Add some real patterns
        # Seasonal pattern
        self.df['seasonal_factor'] = 1 + 0.3 * np.sin(2 * np.pi * (self.df['month'] - 1) / 12)
        self.df['total_revenue'] = self.df['total_revenue'] * self.df['seasonal_factor']
        
        # Trend
        self.df['trend'] = 1 + (self.df['date'] - self.df['date'].min()).dt.days / 365 * 0.15
        self.df['total_revenue'] = self.df['total_revenue'] * self.df['trend']
        
        return self.df
    
    def prepare_features(self):
        """Prepare features for modeling"""
        if self.df is None:
            self.load_sample_data()
            
        # Select relevant features
        spend_features = [
            'paid_search_net_spend', 'paid_shopping_net_spend', 
            'paid_display_net_spend', 'paid_social_net_spend'
        ]
        
        # Create lagged variables
        for feature in spend_features:
            for lag in [1, 7, 30]:  # 1-day, 1-week, 1-month lags
                self.df[f'{feature}_lag_{lag}'] = self.df[feature].shift(lag)
        
        # Create rolling averages
        for feature in spend_features:
            self.df[f'{feature}_rolling_7'] = self.df[feature].rolling(7).mean()
            self.df[f'{feature}_rolling_30'] = self.df[feature].rolling(30).mean()
        
        # Create seasonal features
        self.df['month_sin'] = np.sin(2 * np.pi * self.df['month']/12)
        self.df['month_cos'] = np.cos(2 * np.pi * self.df['month']/12)
        self.df['day_sin'] = np.sin(2 * np.pi * self.df['day_of_week']/7)
        self.df['day_cos'] = np.cos(2 * np.pi * self.df['day_of_week']/7)
        
        # Create holiday dummy
        self.df['is_holiday'] = (self.df['holiday'] != 'None').astype(int)
        
        # Create promo type dummies
        promo_dummies = pd.get_dummies(self.df['day_type'], prefix='promo')
        self.df = pd.concat([self.df, promo_dummies], axis=1)
        
        # Drop rows with NaN values from lag features
        self.df = self.df.dropna()
        
        return self.df
    
    def train_model(self, model_type='linear'):
        """Train the marketing mix model"""
        if self.df is None:
            self.prepare_features()
            
        # Define features and target
        feature_columns = [
            'paid_search_net_spend', 'paid_shopping_net_spend', 
            'paid_display_net_spend', 'paid_social_net_spend',
            'paid_search_net_spend_rolling_7', 'paid_shopping_net_spend_rolling_7',
            'paid_display_net_spend_rolling_7', 'paid_social_net_spend_rolling_7',
            'month_sin', 'month_cos', 'day_sin', 'day_cos', 'is_holiday'
        ]
        
        # Add promo type features
        promo_features = [col for col in self.df.columns if col.startswith('promo_')]
        feature_columns.extend(promo_features)
        
        X = self.df[feature_columns]
        y = self.df['total_revenue']
        
        # Split data
        X_train, X_test, y_train, y_test = train_test_split(
            X, y, test_size=0.2, random_state=42, shuffle=False
        )
        
        # Scale features
        X_train_scaled = self.scaler.fit_transform(X_train)
        X_test_scaled = self.scaler.transform(X_test)
        
        # Train model
        if model_type == 'linear':
            self.model = LinearRegression()
        elif model_type == 'ridge':
            self.model = Ridge(alpha=1.0)
        elif model_type == 'lasso':
            self.model = Lasso(alpha=1.0)
        elif model_type == 'random_forest':
            self.model = RandomForestRegressor(n_estimators=100, random_state=42)
        
        self.model.fit(X_train_scaled, y_train)
        
        # Make predictions
        y_pred = self.model.predict(X_test_scaled)
        
        # Calculate feature importance
        if hasattr(self.model, 'coef_'):
            self.feature_importance = pd.DataFrame({
                'feature': feature_columns,
                'importance': abs(self.model.coef_)
            }).sort_values('importance', ascending=False)
        elif hasattr(self.model, 'feature_importances_'):
            self.feature_importance = pd.DataFrame({
                'feature': feature_columns,
                'importance': self.model.feature_importances_
            }).sort_values('importance', ascending=False)
        
        # Calculate metrics
        mae = mean_absolute_error(y_test, y_pred)
        rmse = np.sqrt(mean_squared_error(y_test, y_pred))
        r2 = r2_score(y_test, y_pred)
        
        self.model_results = {
            'model': self.model,
            'feature_importance': self.feature_importance,
            'metrics': {
                'MAE': mae,
                'RMSE': rmse,
                'R2': r2
            },
            'predictions': {
                'actual': y_test,
                'predicted': y_pred,
                'dates': self.df.loc[y_test.index, 'date']
            },
            'features_used': feature_columns
        }
        
        return self.model_results

# Initialize the MMM model
mmm = MarketingMixModel()

print("📊 Marketing Mix Modeling Dashboard")
print("=" * 50)

def display_header(text):
    display(HTML(f"<h2 style='color: #1f77b4; border-bottom: 2px solid #1f77b4; padding-bottom: 10px;'>{text}</h2>"))

def display_subheader(text):
    display(HTML(f"<h3 style='color: #2e86ab; margin-top: 20px;'>{text}</h3>"))

def display_info(text):
    display(HTML(f"<div style='background-color: #e7f3ff; padding: 15px; border-radius: 8px; border-left: 5px solid #1f77b4; margin: 10px 0;'>{text}</div>"))

def display_warning(text):
    display(HTML(f"<div style='background-color: #fff3cd; padding: 15px; border-radius: 8px; border-left: 5px solid #ffc107; margin: 10px 0;'>{text}</div>"))

def display_success(text):
    display(HTML(f"<div style='background-color: #d4edda; padding: 15px; border-radius: 8px; border-left: 5px solid #28a745; margin: 10px 0;'>{text}</div>"))

# Section 1: Data Overview
display_header("📈 1. Data Overview")
display_info("Loading and exploring the marketing dataset...")

# Load data
df = mmm.load_sample_data()
df_prepared = mmm.prepare_features()

print(f"📈 Dataset Shape: {df.shape}")
print(f"📅 Date Range: {df['date'].min()} to {df['date'].max()}")

# Key metrics
total_revenue = df['total_revenue'].sum()
avg_daily_revenue = df['total_revenue'].mean()
total_spend = df[['paid_search_net_spend', 'paid_shopping_net_spend', 
                 'paid_display_net_spend', 'paid_social_net_spend']].sum().sum()
overall_roi = (total_revenue - total_spend) / total_spend if total_spend > 0 else 0

metrics_data = {
    'Metric': ['Total Revenue', 'Average Daily Revenue', 'Total Marketing Spend', 'Overall ROI'],
    'Value': [f"${total_revenue:,.0f}", f"${avg_daily_revenue:,.0f}", 
              f"${total_spend:,.0f}", f"{overall_roi:.1%}"]
}

metrics_df = pd.DataFrame(metrics_data)
display(metrics_df.style.set_properties(**{'background-color': '#f8f9fa', 'border': '1px solid #dee2e6'}))

# Dataset preview
display_subheader("Dataset Preview")
display(df.head(10).style.background_gradient(subset=['total_revenue'], cmap='Blues'))

# Key statistics
display_subheader("Key Statistics")
numeric_cols = df.select_dtypes(include=[np.number]).columns
key_metrics = ['paid_search_net_spend', 'paid_search_revenue', 
               'paid_shopping_net_spend', 'paid_shopping_revenue',
               'paid_display_net_spend', 'paid_display_revenue',
               'paid_social_net_spend', 'paid_social_revenue',
               'total_revenue']

display(df[key_metrics].describe().style.format("{:,.2f}"))

# Section 2: Exploratory Analysis
display_header("🔍 2. Exploratory Analysis")

# Time series analysis
display_subheader("Revenue & Marketing Spend Over Time")

fig = make_subplots(
    rows=2, cols=1, 
    shared_xaxes=True,
    subplot_titles=('Total Revenue Over Time', 'Marketing Spend by Channel'),
    vertical_spacing=0.1
)

# Revenue plot
fig.add_trace(
    go.Scatter(x=df['date'], y=df['total_revenue'], name='Total Revenue', 
               line=dict(color='blue', width=2), fill='tozeroy', fillcolor='rgba(0,0,255,0.1)'),
    row=1, col=1
)

# Spend plot
spend_columns = ['paid_search_net_spend', 'paid_shopping_net_spend', 
                'paid_display_net_spend', 'paid_social_net_spend']

colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4']
for col, color in zip(spend_columns, colors):
    channel_name = col.replace('_net_spend', '').replace('_', ' ').title()
    fig.add_trace(
        go.Scatter(x=df['date'], y=df[col], name=channel_name,
                   line=dict(color=color, width=1.5)),
        row=2, col=1
    )

fig.update_layout(
    height=600, 
    showlegend=True, 
    title_text="Marketing Performance Over Time",
    template="plotly_white"
)
fig.show()

# Channel Performance Analysis
display_subheader("Channel Performance Analysis")

# Create subplots
fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))

# ROI by channel
channel_roi = {}
channel_names = []
roi_values = []

for channel in ['search', 'shopping', 'display', 'social']:
    spend_col = f'paid_{channel}_net_spend'
    revenue_col = f'paid_{channel}_revenue'
    total_spend = df[spend_col].sum()
    total_revenue = df[revenue_col].sum()
    roi = (total_revenue - total_spend) / total_spend if total_spend > 0 else 0
    channel_roi[channel.title()] = roi * 100
    channel_names.append(channel.title())
    roi_values.append(roi * 100)

# Plot 1: ROI by Channel
bars = ax1.bar(channel_names, roi_values, color=colors, alpha=0.8)
ax1.set_title('Return on Investment by Channel', fontsize=14, fontweight='bold')
ax1.set_ylabel('ROI (%)', fontsize=12)
ax1.tick_params(axis='x', rotation=45)
ax1.grid(True, alpha=0.3)
for i, (bar, v) in enumerate(zip(bars, roi_values)):
    ax1.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 1, 
             f'{v:.1f}%', ha='center', va='bottom', fontweight='bold')

# Plot 2: Spend Distribution
spend_data = []
spend_labels = []
for channel in ['search', 'shopping', 'display', 'social']:
    spend_col = f'paid_{channel}_net_spend'
    total_spend = df[spend_col].sum()
    spend_data.append(total_spend)
    spend_labels.append(channel.title())

wedges, texts, autotexts = ax2.pie(spend_data, labels=spend_labels, 
        autopct='%1.1f%%', colors=colors, startangle=90)
ax2.set_title('Marketing Spend Distribution', fontsize=14, fontweight='bold')

# Plot 3: Monthly Revenue Pattern
monthly_data = df.groupby('month').agg({
    'total_revenue': 'mean'
}).reset_index()

ax3.plot(monthly_data['month'], monthly_data['total_revenue'], 
         marker='o', linewidth=3, markersize=8, color='#1f77b4')
ax3.set_title('Average Monthly Revenue Pattern', fontsize=14, fontweight='bold')
ax3.set_xlabel('Month', fontsize=12)
ax3.set_ylabel('Average Revenue ($)', fontsize=12)
ax3.grid(True, alpha=0.3)
ax3.set_xticks(range(1, 13))

# Plot 4: Correlation Heatmap
corr_matrix = df[['paid_search_net_spend', 'paid_shopping_net_spend', 
                 'paid_display_net_spend', 'paid_social_net_spend', 'total_revenue']].corr()
im = ax4.imshow(corr_matrix, cmap='RdBu_r', aspect='auto', vmin=-1, vmax=1)
ax4.set_xticks(range(len(corr_matrix.columns)))
ax4.set_yticks(range(len(corr_matrix.columns)))
ax4.set_xticklabels([col.replace('_net_spend', '').replace('_', ' ').title() 
                    if 'net_spend' in col else 'Total Revenue' for col in corr_matrix.columns], 
                   rotation=45, ha='right')
ax4.set_yticklabels([col.replace('_net_spend', '').replace('_', ' ').title() 
                    if 'net_spend' in col else 'Total Revenue' for col in corr_matrix.columns])
ax4.set_title('Spend-Revenue Correlation Matrix', fontsize=14, fontweight='bold')

# Add correlation values to heatmap
for i in range(len(corr_matrix.columns)):
    for j in range(len(corr_matrix.columns)):
        text = ax4.text(j, i, f'{corr_matrix.iloc[i, j]:.2f}',
                       ha="center", va="center", color="black", fontweight='bold')

plt.tight_layout()
plt.show()

# Section 3: MMM Modeling
display_header("🤖 3. Marketing Mix Modeling")

model_type = 'random_forest'  # You can change this to test different models

display_subheader(f"Training {model_type.replace('_', ' ').title()} Model...")

with st.spinner("Training model... This may take a few moments.") if 'st' in locals() else display_info("Training model... This may take a few moments."):
    results = mmm.train_model(model_type)

display_success("✅ Model trained successfully!")

# Display model metrics
metrics = results['metrics']
display_subheader("Model Performance Metrics")

metrics_data = [
    ['R² Score', f"{metrics['R2']:.4f}", "good" if metrics['R2'] > 0.7 else "fair" if metrics['R2'] > 0.5 else "poor"],
    ['Mean Absolute Error', f"${metrics['MAE']:,.0f}", "good" if metrics['MAE'] < df['total_revenue'].std() else "fair"],
    ['Root Mean Square Error', f"${metrics['RMSE']:,.0f}", "good" if metrics['RMSE'] < df['total_revenue'].std() * 1.5 else "fair"],
    ['Mean Absolute Percentage Error', f"{(metrics['MAE']/df['total_revenue'].mean())*100:.1f}%", "good" if (metrics['MAE']/df['total_revenue'].mean()) < 0.2 else "fair"]
]

metrics_df = pd.DataFrame(metrics_data, columns=['Metric', 'Value', 'Quality'])
display(metrics_df.style.applymap(lambda x: 'background-color: #d4edda' if x == 'good' else 'background-color: #fff3cd' if x == 'fair' else 'background-color: #f8d7da', subset=['Quality']))

# Actual vs Predicted plot
display_subheader("Model Predictions vs Actual Values")

pred_data = results['predictions']

fig = go.Figure()

fig.add_trace(go.Scatter(
    x=pred_data['dates'], y=pred_data['actual'],
    name='Actual Revenue', mode='lines+markers', 
    line=dict(color='blue', width=2),
    marker=dict(size=4)
))

fig.add_trace(go.Scatter(
    x=pred_data['dates'], y=pred_data['predicted'],
    name='Predicted Revenue', mode='lines+markers',
    line=dict(color='red', width=2, dash='dash'),
    marker=dict(size=4)
))

fig.update_layout(
    title='Actual vs Predicted Revenue',
    xaxis_title='Date',
    yaxis_title='Revenue ($)',
    showlegend=True,
    height=500,
    template="plotly_white"
)

fig.show()

# Feature Importance
display_subheader("Feature Importance Analysis")

importance_df = results['feature_importance'].head(15)

fig = px.bar(
    importance_df,
    x='importance',
    y='feature',
    orientation='h',
    title='Top 15 Most Important Features',
    color='importance',
    color_continuous_scale='viridis'
)

fig.update_layout(
    height=500, 
    yaxis={'categoryorder':'total ascending'},
    template="plotly_white"
)
fig.show()

# Section 4: Results & Insights
display_header("💡 4. Results & Business Insights")

display_subheader("Key Marketing Insights")

# Create insights columns
col1, col2 = widgets.Output(), widgets.Output()

with col1:
    display_info("📊 Channel Contribution Analysis")
    channel_contributions = results['feature_importance'][
        results['feature_importance']['feature'].str.contains('net_spend') & 
        ~results['feature_importance']['feature'].str.contains('rolling|lag')
    ].head(4)
    
    for _, row in channel_contributions.iterrows():
        channel_name = row['feature'].replace('_net_spend', '').replace('_', ' ').title()
        display(HTML(f"• <b>{channel_name}</b>: {row['importance']:.4f}"))

with col2:
    display_info("🎯 Model Performance Insights")
    display(HTML(f"• <b>R² Score</b>: {results['metrics']['R2']:.4f}"))
    display(HTML(f"• <b>Prediction Error</b>: ${results['metrics']['MAE']:,.0f}"))
    best_channel = channel_contributions.iloc[0]['feature'].split('_')[1].title()
    display(HTML(f"• <b>Most Impactful Channel</b>: {best_channel}"))
    display(HTML(f"• <b>Model Type</b>: {model_type.replace('_', ' ').title()}"))

display(widgets.HBox([col1, col2]))

# ROI Analysis
display_subheader("Return on Investment Analysis")

roi_data = []
for channel in ['search', 'shopping', 'display', 'social']:
    spend_col = f'paid_{channel}_net_spend'
    revenue_col = f'paid_{channel}_revenue'
    total_spend = df[spend_col].sum()
    total_revenue = df[revenue_col].sum()
    roi = (total_revenue - total_spend) / total_spend if total_spend > 0 else 0
    
    efficiency = 'High' if roi > 2 else 'Medium' if roi > 1 else 'Low'
    
    roi_data.append({
        'Channel': channel.title(),
        'Total Spend': total_spend,
        'Total Revenue': total_revenue,
        'ROI (%)': roi * 100,
        'Efficiency': efficiency
    })

roi_df = pd.DataFrame(roi_data)

def color_efficiency(val):
    if val == 'High': return 'background-color: #d4edda'
    elif val == 'Medium': return 'background-color: #fff3cd'
    else: return 'background-color: #f8d7da'

display(roi_df.style.format({
    'Total Spend': '${:,.0f}',
    'Total Revenue': '${:,.0f}',
    'ROI (%)': '{:.1f}%'
}).background_gradient(subset=['ROI (%)'], cmap='RdYlGn').applymap(color_efficiency, subset=['Efficiency']))

# Budget Allocation Recommendations
display_header("💰 5. Budget Optimization")

display_subheader("Budget Allocation Recommendations")

# Interactive budget slider
def optimize_budget(total_budget):
    # Allocate based on ROI performance
    roi_df_copy = roi_df.copy()
    roi_df_copy['Weight'] = roi_df_copy['ROI (%)'] / roi_df_copy['ROI (%)'].sum()
    roi_df_copy['Recommended Allocation'] = roi_df_copy['Weight'] * total_budget
    roi_df_copy['Recommended vs Current'] = roi_df_copy['Recommended Allocation'] - roi_df_copy['Total Spend']
    
    # Plot
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))
    
    # Current vs Recommended
    channels = roi_df_copy['Channel']
    current = roi_df_copy['Total Spend']
    recommended = roi_df_copy['Recommended Allocation']
    
    x = np.arange(len(channels))
    width = 0.35
    
    bars1 = ax1.bar(x - width/2, current, width, label='Current', alpha=0.7, color='#6c757d')
    bars2 = ax1.bar(x + width/2, recommended, width, label='Recommended', alpha=0.7, color='#28a745')
    ax1.set_xlabel('Channel', fontsize=12)
    ax1.set_ylabel('Budget ($)', fontsize=12)
    ax1.set_title('Current vs Recommended Budget Allocation', fontsize=14, fontweight='bold')
    ax1.set_xticks(x)
    ax1.set_xticklabels(channels)
    ax1.legend()
    ax1.grid(True, alpha=0.3)
    
    # Add value labels on bars
    for bar in bars1:
        height = bar.get_height()
        ax1.text(bar.get_x() + bar.get_width()/2., height,
                f'${height:,.0f}', ha='center', va='bottom')
    
    for bar in bars2:
        height = bar.get_height()
        ax1.text(bar.get_x() + bar.get_width()/2., height,
                f'${height:,.0f}', ha='center', va='bottom')
    
    # Changes
    changes = roi_df_copy['Recommended vs Current']
    colors_changes = ['#28a745' if x > 0 else '#dc3545' for x in changes]
    bars3 = ax2.bar(channels, changes, color=colors_changes, alpha=0.7)
    ax2.set_xlabel('Channel', fontsize=12)
    ax2.set_ylabel('Budget Change ($)', fontsize=12)
    ax2.set_title('Recommended Budget Changes', fontsize=14, fontweight='bold')
    ax2.tick_params(axis='x', rotation=45)
    ax2.grid(True, alpha=0.3)
    
    # Add value labels
    for i, v in enumerate(changes):
        color = 'green' if v > 0 else 'red'
        ax2.text(i, v + (1000 if v > 0 else -5000), f'${v:,.0f}', 
                ha='center', va='bottom' if v > 0 else 'top', 
                fontweight='bold', color=color)
    
    plt.tight_layout()
    plt.show()
    
    # Summary
    display_subheader("Allocation Summary")
    for _, row in roi_df_copy.iterrows():
        change = row['Recommended vs Current']
        if change > 0:
            display(HTML(f"• <b>{row['Channel']}</b>: 📈 Increase by <b style='color: green;'>${abs(change):,.0f}</b>"))
        else:
            display(HTML(f"• <b>{row['Channel']}</b>: 📉 Decrease by <b style='color: red;'>${abs(change):,.0f}</b>"))

# Interactive budget optimization
display_info("Adjust the total budget to see optimized allocation:")
interact(optimize_budget, total_budget=widgets.IntSlider(
    min=100000, 
    max=1000000, 
    value=500000, 
    step=50000,
    description='Total Budget:',
    style={'description_width': 'initial'}
))

# Budget Optimization Simulator
display_subheader("Marketing Budget Simulator")

def simulate_budget(search_budget, shopping_budget, display_budget, social_budget):
    """Simulate revenue based on budget allocation"""
    if mmm.model is None:
        display(HTML("<div style='color: red;'>Please train the model first in Section 3.</div>"))
        return
    
    try:
        # Prepare input features for prediction
        input_features = np.array([[
            search_budget, shopping_budget, display_budget, social_budget,
            search_budget, shopping_budget, display_budget, social_budget,  # rolling averages (same as current)
            0, 0, 0, 0, 0  # seasonal and holiday features (set to average)
        ]])
        
        # Add promo features (assuming average day)
        promo_features = np.zeros((1, 8))  # 8 promo types
        input_features = np.concatenate([input_features, promo_features], axis=1)
        
        # Scale features and predict
        input_scaled = mmm.scaler.transform(input_features)
        predicted_revenue = mmm.model.predict(input_scaled)[0]
        
        total_budget = search_budget + shopping_budget + display_budget + social_budget
        predicted_roi = (predicted_revenue - total_budget) / total_budget if total_budget > 0 else 0
        
        # Display results
        roi_color = "green" if predicted_roi > 0.5 else "orange" if predicted_roi > 0 else "red"
        
        results_html = f"""
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; border-radius: 10px; color: white;">
            <h3 style="margin-top: 0; color: white;">Simulation Results</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                <div style="background: rgba(255,255,255,0.2); padding: 15px; border-radius: 8px;">
                    <h4 style="margin: 0; color: white;">Budget</h4>
                    <p style="font-size: 24px; margin: 10px 0; font-weight: bold;">${total_budget:,.0f}</p>
                </div>
                <div style="background: rgba(255,255,255,0.2); padding: 15px; border-radius: 8px;">
                    <h4 style="margin: 0; color: white;">Predicted Revenue</h4>
                    <p style="font-size: 24px; margin: 10px 0; font-weight: bold;">${predicted_revenue:,.0f}</p>
                </div>
                <div style="background: rgba(255,255,255,0.2); padding: 15px; border-radius: 8px; grid-column: span 2;">
                    <h4 style="margin: 0; color: white;">Predicted ROI</h4>
                    <p style="font-size: 24px; margin: 10px 0; font-weight: bold; color: {roi_color};">{predicted_roi:.1%}</p>
                </div>
            </div>
            <div style="margin-top: 15px;">
                <p><b>Channel Mix:</b> Search ({search_budget/total_budget:.1%}), 
                Shopping ({shopping_budget/total_budget:.1%}), 
                Display ({display_budget/total_budget:.1%}), 
                Social ({social_budget/total_budget:.1%})</p>
            </div>
        </div>
        """
        display(HTML(results_html))
        
    except Exception as e:
        display(HTML(f"<div style='color: red;'>Error in simulation: {str(e)}</div>"))

# Interactive budget sliders
display_info("Adjust channel budgets to see predicted revenue impact:")

interact(simulate_budget, 
         search_budget=widgets.IntSlider(min=0, max=300000, value=150000, step=10000, description='Search:'),
         shopping_budget=widgets.IntSlider(min=0, max=300000, value=120000, step=10000, description='Shopping:'),
         display_budget=widgets.IntSlider(min=0, max=300000, value=80000, step=10000, description='Display:'),
         social_budget=widgets.IntSlider(min=0, max=300000, value=100000, step=10000, description='Social:'))

# Scenario Analysis
display_subheader("Scenario Analysis")

scenarios = {
    "Current Allocation": [150000, 120000, 80000, 100000],
    "ROI Optimized": [200000, 150000, 50000, 120000],
    "Balanced Mix": [180000, 130000, 60000, 110000],
    "Aggressive Growth": [250000, 180000, 70000, 150000],
    "Conservative": [120000, 100000, 40000, 80000]
}

scenario_results = []
for scenario_name, budgets in scenarios.items():
    try:
        input_features = np.array([[
            budgets[0], budgets[1], budgets[2], budgets[3],
            budgets[0], budgets[1], budgets[2], budgets[3],
            0, 0, 0, 0, 0
        ]])
        promo_features = np.zeros((1, 8))
        input_features = np.concatenate([input_features, promo_features], axis=1)
        
        input_scaled = mmm.scaler.transform(input_features)
        predicted_revenue = mmm.model.predict(input_scaled)[0]
        total_budget = sum(budgets)
        roi = (predicted_revenue - total_budget) / total_budget
        
        scenario_results.append({
            'Scenario': scenario_name,
            'Search Budget': budgets[0],
            'Shopping Budget': budgets[1],
            'Display Budget': budgets[2],
            'Social Budget': budgets[3],
            'Total Budget': total_budget,
            'Predicted Revenue': predicted_revenue,
            'ROI': roi
        })
    except:
        continue

if scenario_results:
    scenario_df = pd.DataFrame(scenario_results)

    # Display scenario comparison
    display(scenario_df.style.format({
        'Search Budget': '${:,.0f}',
        'Shopping Budget': '${:,.0f}', 
        'Display Budget': '${:,.0f}',
        'Social Budget': '${:,.0f}',
        'Total Budget': '${:,.0f}',
        'Predicted Revenue': '${:,.0f}',
        'ROI': '{:.1%}'
    }).background_gradient(subset=['ROI'], cmap='RdYlGn'))

    # Visualization of scenarios
    fig = go.Figure()

    scenarios_list = scenario_df['Scenario'].tolist()

    # Add budget bars
    fig.add_trace(go.Bar(
        name='Total Budget',
        x=scenarios_list,
        y=scenario_df['Total Budget'],
        marker_color='lightblue',
        text=scenario_df['Total Budget'].apply(lambda x: f'${x:,.0f}'),
        textposition='auto'
    ))

    # Add revenue bars
    fig.add_trace(go.Bar(
        name='Predicted Revenue', 
        x=scenarios_list,
        y=scenario_df['Predicted Revenue'],
        marker_color='lightgreen',
        text=scenario_df['Predicted Revenue'].apply(lambda x: f'${x:,.0f}'),
        textposition='auto'
    ))

    fig.update_layout(
        title='Budget Scenarios Comparison',
        xaxis_title='Scenario',
        yaxis_title='Amount ($)',
        barmode='group',
        height=500,
        template="plotly_white"
    )

    fig.show()

# Final Summary
display_header("🎯 Executive Summary")

# Find best scenario and channel
best_channel = roi_df.loc[roi_df['ROI (%)'].idxmax(), 'Channel'] if not roi_df.empty else "Search"
model_fit = "strong" if results['metrics']['R2'] > 0.7 else "moderate" if results['metrics']['R2'] > 0.5 else "weak"
best_scenario = scenario_df.loc[scenario_df['ROI'].idxmax(), 'Scenario'] if scenario_results else "ROI Optimized"

summary_html = f"""
<div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 25px; border-radius: 15px; color: white; margin: 20px 0;">
    <h2 style="margin-top: 0; color: white; text-align: center;">📊 Executive Summary</h2>
    
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
        <div style="background: rgba(255,255,255,0.2); padding: 20px; border-radius: 10px;">
            <h3 style="color: white; border-bottom: 2px solid white; padding-bottom: 10px;">📈 Performance Insights</h3>
            <ul style="color: white;">
                <li><b>Best Performing Channel:</b> {best_channel} based on ROI and impact</li>
                <li><b>Model Accuracy:</b> R² score of {results['metrics']['R2']:.3f} indicates {model_fit} fit</li>
                <li><b>Seasonal Patterns:</b> Clear monthly and weekly trends detected</li>
                <li><b>Prediction Error:</b> ${results['metrics']['MAE']:,.0f} ({(results['metrics']['MAE']/df['total_revenue'].mean())*100:.1f}% of average revenue)</li>
            </ul>
        </div>
        
        <div style="background: rgba(255,255,255,0.2); padding: 20px; border-radius: 10px;">
            <h3 style="color: white; border-bottom: 2px solid white; padding-bottom: 10px;">💰 Budget Recommendations</h3>
            <ul style="color: white;">
                <li><b>Increase investment</b> in high-ROI channels</li>
                <li><b>Optimize seasonal spending</b> based on predictive patterns</li>
                <li><b>Reallocate budget</b> from underperforming channels</li>
                <li><b>Recommended Scenario:</b> {best_scenario} for optimal results</li>
            </ul>
        </div>
    </div>
    
    <div style="background: rgba(255,255,255,0.2); padding: 20px; border-radius: 10px; margin-top: 20px;">
        <h3 style="color: white; border-bottom: 2px solid white; padding-bottom: 10px;">🎯 Strategic Actions</h3>
        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; text-align: center;">
            <div>
                <h4 style="color: white; margin: 10px 0;">📊 Monitor</h4>
                <p style="margin: 0; font-size: 12px;">Channel performance weekly</p>
            </div>
            <div>
                <h4 style="color: white; margin: 10px 0;">🔄 Test</h4>
                <p style="margin: 0; font-size: 12px;">New promotional strategies</p>
            </div>
            <div>
                <h4 style="color: white; margin: 10px 0;">📈 Optimize</h4>
                <p style="margin: 0; font-size: 12px;">Budget allocation monthly</p>
            </div>
        </div>
    </div>
</div>
"""

display(HTML(summary_html))

print("\n" + "="*70)
print("✅ Marketing Mix Modeling Analysis Complete!")
print("="*70)
print("\n📋 Next Steps:")
print("1. Review channel performance and ROI analysis")
print("2. Implement recommended budget allocations") 
print("3. Monitor model performance and retrain periodically")
print("4. Test different scenarios using the budget simulator")
print("="*70)
